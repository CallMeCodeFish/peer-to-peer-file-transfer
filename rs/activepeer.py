#!usr/bin/python3
# -*- coding: utf-8 -*-
'''
# Created on Sep-15-19 11:36
# activepeer.py
# theme: class declaration of active peer
# @author: Heng Yu
'''

import time
import threading

class ActivePeer(object):
    '''
    ========================== instance Member variable list =========================
    #variable name           #variable type               #generated by
    hostname                 string                       input
    cookie                   int                          class varible: ActivePeer.cookie
    isactive                 bool                         set by __init__
    ttl                      int                          reset outside
    port                     int                          input
    activetimes              int                          reset outside
    recentconnection         time_struct                  reset outside
    ==================================================================================
    '''
    #类变量
    cookie = 0
    ttl_default = 7200
    # ttl_default = 3

    #构造函数
    def __init__(self, hostname, port):
        
        self.hostname = hostname
        self.port = port

        ActivePeer.cookie += 1
        self.cookie = ActivePeer.cookie

        self.isactive = True
        self.activetimes = 1
        self.recentconnection = time.localtime(time.time())
        self.ttl = ActivePeer.ttl_default
        
        #两把线程锁: 针对数据对象self.ttl和self.isactive
        self._threadLock_at = threading.Lock()
        self._threadLock_ttl = threading.Lock()
    
    #析构函数
    # //code

    #此前inactive的client重新注册成为active状态
    def register(self):
        self._reconnect()
        self._set_isactive_to_true()
        self._set_ttl_to_default()


    #client重连到rs后更新此client的信息
    #当self.isactive = True时，调用self.keep_alive()
    def keep_alive(self):
        self._reconnect()
        self._set_ttl_to_default()


    #client要求离开p2p系统
    def leave(self):
        self._reconnect()
        self._set_isactive_to_false()
        self._set_ttl_to_0()

    
    #client请求pquery
    def pquery(self):
        self.keep_alive()
        

    #ttl递减:
    def ttl_decrement(self):
        self._threadLock_ttl.acquire()
        while 0 < self.ttl:
            self.ttl -= 1
            self._threadLock_ttl.release()
            time.sleep(1)
            self._threadLock_ttl.acquire()
            # print("ttl = %d" %self.ttl)
        #ttl = 0时，将isactive置false
        self._threadLock_ttl.release()
        self._set_isactive_to_false()
        

    #私有方法
    def _reconnect(self):
        self.recentconnection = time.localtime(time.time())
        self.activetimes += 1


    def _set_ttl_to_default(self):
        self._threadLock_ttl.acquire()
        self.ttl = ActivePeer.ttl_default
        self._threadLock_ttl.release()
        

    def _set_ttl_to_0(self):
        self._threadLock_ttl.acquire()
        self.ttl = 0
        self._threadLock_ttl.release()


    def _set_isactive_to_true(self):
        self._threadLock_at.acquire()
        self.isactive = True
        self._threadLock_at.release()


    def _set_isactive_to_false(self):
        self._threadLock_at.acquire()
        self.isactive = False
        self._threadLock_at.release()


#打印ActivePeer对象属性的函数
def show_attributes_of_activepeer(ap):
    print("hostname: ", ap.hostname)
    print("port: ", ap.port)
    print("cookie: ", ap.cookie)
    print("isactive: ", ap.isactive)
    print("ttl: ", ap.ttl)
    print("activetimes: ", ap.activetimes)
    print("recentconnection: ", time.asctime(ap.recentconnection))
